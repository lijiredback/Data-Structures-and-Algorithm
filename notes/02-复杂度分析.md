数据结构和算法解决两个问题：
+ 快（代码运行的更快）
+ 省（代码更省存储空间）

### 大 O 复杂度表示法

**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**

```
T(n) = O(f(n))
// T(n)：代码执行的时间；
// n 表示数据规模的大小；
// f(n) 表示每行代码执行的次数总和；
```

### 时间复杂度分析

#### 1.只关注循环执行次数最多的一段代码

```
int cal(int n) {
    int sum = 0;
    int i = 1;
    for (; i <= n; ++i) { // 执行 n 次
        sum = sum + i; // 执行 n 次
    }
    return sum
}
```

以上代码的时间复杂度为 O(n)

#### 2.加法法则：总复杂度等于量级最大的那段代码的复杂度

```
int cal(int n) {
    int sum_1 = 0;
    int p = 1;
    for(; p < 100; ++p) { // O(1)
        sum_1 = sum_1 + p;
    }

    int sum_2 = 0;
    int q = 1;
    for(; q < n; ++q) { // O(n)
        sum_2 = sum_2 + q; // O(n)
    }

    int sum_3 = 0;
    int i = 1;
    int j = 1;
    for(; i <= n; ++j) { // O(n)
        j = 1; // O(n)
        for(; j <= n; ++j) { // O(n^2)
            sum_3 = sum_3 + i * j; // O(n^2)
        }
    }

    return sum_1 + sum_2 + sum_3;
}

```

以上代码的时间复杂度为：O(n^2)

#### 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

```
int cal(int n) {
    int ret = 0;
    int i = 1;
    for(; i < n; ++i) {
        ret = ret + f(i);
    }
}

int f(int n) {
    int sum = 0;
    int i = 1;
    for(; i < n; ++i) {
        sum = sum + i;
    }
    return sum;
}
```

假设 f() 是一个普通操作，那么 cal() 中的循环，时间复杂度就是 O(n)。但是 f() 函数本身不是一个简单操作，时间复杂也是 O(n)。所以，整个 cal() 函数的时间复杂度是 O(n^2)。

### 几种常见时间复杂度分析

复杂度量级（递增）
+ 常量阶 O(1)
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行代码，其时间复杂度也是 O(1)

+ 对数阶 O(logn)
```
i = 1;
while (i <= n) {
    i = i * 2;
}
```

+ 线性阶 O(n)

+ 线性对数阶 O(nlogn)
归并排序、快速排序

+ 平方阶 O(n^2)、立方阶 O(n^3)、k 次方阶 O(n^k)
+ 指数阶 O(2^n)
+ 阶乘阶 O(n!)

### 空间复杂度分析

常见：O(1)、O(n)、O(n^2)

### 最好、最坏情况时间复杂度

```
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for(; i < n; ++i) {
        if (array[i] == x) pos = i;
    }
    return pos;
}
```

查找数据，我们可能中途就找到了，所以可以优化代码

```
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for(; i < n; ++i) {
        if (array[i] == x) {
            pos = i;
            break;
        }
    }
    return pos;
}
```

优化过后的代码，如果数组中第一个元素就是要查找的变量 x，那么时间复杂度就是 O(1)；如果数组中没有变量 x，那么时间复杂度就是 O(n)。

**最好情况时间复杂度：在最理想情况下，这段代码的时间复杂度。**

**最坏情况时间复杂度：在最糟糕的情况下，这段代码的时间复杂度。**

### 平均情况时间复杂度（加权）

### 均摊时间复杂度

分析方法：摊还分析或者叫平摊分析。