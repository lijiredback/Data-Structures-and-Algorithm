### 数组的概念及随机访问

数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

+ 线性表
    - 线性表上的数据只有前、后两个方向
    - 线性表结构：数组、链表、队列、栈等
    - 非线性表：二叉树、堆、图
+ 连续的内存空间和相同的数据类型
    - 优点：可以“随机访问”
    - 缺点：操作低效(比如要在数组中插入或删除一个数据，为了保证连续性，就要做大量数据搬移的工作)

#### 数组如何实现根据下标随机访问数组元素？

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。

```
a[i]_address = base_address + i * data_type_size

// data_type_size 是数组中每个元素的大小
// int 类型的数组，data_type_size 就是 4 个字节
```

#### 数组与链表的区别

数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)

### 数组低效的”插入“和”删除“

低效：因为数组要保持内存空间的连续性。

#### 插入操作

如果在数组的末尾插入，不需要移动，时间复杂度为 O(1)。

如果在数组的开头插入，所有数据都需要往后移动一位，时间复杂度为 O(n)。

**思想：**

假设一个**无序**数组中存储了 5 个元素：a、b、c、d、e。如果想把元素 x 插入到第三个位置，就可以将第三个位置的数组挪到最后一位，即a[5] = c; 再把 x 插入到第三个位置，即 a[2] = x。

#### 删除操作

如果在数组的末尾删除，不需要移动，最好时间复杂度为 O(1)。

如果在数组的开头删除，则每个元素都需要向前挪一位，最坏时间复杂度就是 O(n)。

平均时间复杂度也是 O(n)。

**思想：**

在某些特殊的场景下，并不一定要追求数组数据的连续性，可以将多次删除操作集中在一起。

例子：

一个数组有 a、b、c、d、e、f、g、h 8个元素，我需要删除 a、b、c 三个元素，为了不让后面的 d、e、f、g、h 被搬移三次，我们可以先记录下已经删除的数据，等到数组中没有更多的空间存储数据的时候，再触发一次真正的删除操作。

上面也正是 JVM 标记清除垃圾回收算法的核心思想。

### 警惕数组的访问越界问题

### 思考：二位数组的寻址工具

一维数组：
```
const a = [1, 2, 3, 4];

a[k]_address = base_address + k * data_type_size
```

二维数组：

```
const b = [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]];

a[i[j]]_address = base_address + (i * n + j) * data_type_size
```